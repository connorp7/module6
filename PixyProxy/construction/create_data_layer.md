Lets build the data layer for the following system and database schema. Let's use DB-API to do this with a MYSQL backend. The system description is as follows:

'''
The system is a FastAPI-based REST API designed to manage images generated by the OpenAI API. The images are identified by GUIDs for public use and integer IDs for internal use. Each image also has a prompt used to generate it, a filename, and timestamps for creation and updates.

The API provides four endpoints:
1. POST /image: This endpoint generates an image (and image detail) from a prompt.
2. GET /image/{guid}: This endpoint retrieves the details of an image using the provided GUID.
3. GET /image: This endpoint retrieves the details of all images.
4. GET /image/{guid}/content: This endpoint retrieves the image file using the provided GUID.

The system uses a MySQL database to store image details. The database schema includes a table named 'images' with columns for id, guid, filename, prompt, created_at, and updated_at.

The system is structured into four layers:
1. The '/data' layer: This layer uses a repository pattern to interact with the MySQL database. It includes functionality to convert models to dictionaries and vice versa for efficiency. SQL commands use named parameters, and the initialization logic is in an init.py module.
2. The '/service' layer: This layer handles public and private prompt requests in separate modules. It uses pydantic for revalidation of incoming models from the web layer. All exceptions, whether originating from the database or service layer, use a general 'PixyProxyException' format.
3. The '/core' layer: This layer focuses on models and exceptions, all of which extend 'PixyProxyException'.
4. The '/web' layer: This layer manages resources for images. It uses a dependency pattern to ensure required authentication for private resource methods. It also includes a dependency for universal logging of all requests.

The system requires universal request logging in a specific format, with the request-id generated from host-datetime-threadid. All exceptions are handled by a single exception handler. This design ensures a clean separation of concerns, efficient data handling, and robust error management, making the system reliable and maintainable.
'''
Here is the database schema to use:

'''
SET NAMES utf8mb4 COLLATE utf8mb4_unicode_ci;

CREATE TABLE images (
    id INT AUTO_INCREMENT PRIMARY KEY,
    guid VARCHAR(255) NOT NULL,
    filename VARCHAR(255) NOT NULL,
    prompt TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    CONSTRAINT images_U1 UNIQUE (guid),
    INDEX images_I1 (guid)
);

CREATE TABLE roster (
    id INT AUTO_INCREMENT PRIMARY KEY,
    guid VARCHAR(255) NOT NULL,
    user VARCHAR(255) NOT NULL,
    password VARCHAR(255) NOT NULL,
    class_key VARCHAR(255) NOT NULL,
    CONSTRAINT roster_U1 UNIQUE (user),
    CONSTRAINT roster_U2 UNIQUE (guid),
    INDEX roster_I1 (user),
    INDEX roster_I2 (guid)
);


'''
Let's generate:

a list of files needed to cleanly implement the provided Mysql version of the database
complete code for the data layer using a repository pattern with interfaces, models, and exceptions
Don't forget to separate initialisation code into data/init.py
Let's assume use of python-dotenv to read in configuration items
Include a sample .env file with any configuration items needed
specify types and salient docstrings for all public function signatures Let's make sure to cover the following use cases for our system:

'''
Based on the provided information, here are the use cases for the system:

1. **Use Case: Generate an Image**
    - **Actor**: User
    - **Preconditions**: User has a valid prompt.
    - **Postconditions**: An image and image detail are created and stored in the database.
    - **Normal Flow**: User sends a POST request to /image with a prompt. The system generates an image, creates image details, assigns a GUID, and stores all information in the database.

2. **Use Case: Get Image Details by GUID**
    - **Actor**: User
    - **Preconditions**: Image GUID is valid.
    - **Postconditions**: User receives image details.
    - **Normal Flow**: User sends a GET request to /image/{guid}. The system retrieves the image details associated with the provided GUID and returns them to the user.

3. **Use Case: Get Details for All Images**
    - **Actor**: User
    - **Preconditions**: None.
    - **Postconditions**: User receives details for all images.
    - **Normal Flow**: User sends a GET request to /image. The system retrieves the details for all images and returns them to the user.

4. **Use Case: Retrieve Image File by GUID**
    - **Actor**: User
    - **Preconditions**: Image GUID is valid.
    - **Postconditions**: User receives the image file.
    - **Normal Flow**: User sends a GET request to /image/{guid}/content. The system retrieves the image file associated with the provided GUID and returns it to the user.

5. **Use Case: Perform Operations on Private Images**
    - **Actor**: Authenticated User
    - **Preconditions**: User is authenticated.
    - **Postconditions**: User performs operations on private images.
    - **Normal Flow**: User sends a request to any of the above endpoints with authentication credentials. After successful authentication, the system allows the user to perform the requested operation on private images.
'''